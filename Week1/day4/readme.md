# Day 4: GLS, Blocking vs Non-blocking, and Synthesis-Simulation Mismatch

This section explains the importance of post-synthesis verification through Gate Level Simulation (GLS) and delves into one of the most common pitfalls in RTL design: the synthesis-simulation mismatch, often caused by the incorrect use of blocking and non-blocking assignments.

---

## 1. Blocking vs. Non-blocking Statements

In Verilog, the assignment operators (`=` and `<=`) have fundamentally different behaviors within procedural blocks (`always`). Understanding this difference is crucial for writing synthesizable code that behaves as intended.

### Blocking Assignments (`=`)

-   **Behavior:** Executed **sequentially**. The next statement is "blocked" until the current one is complete.
-   **Use Case:** For modeling **combinational logic** in `always @(*)` blocks.
-   **Warning:** Using them in `always @(posedge clk)` blocks for sequential logic often leads to mismatches between simulation and the synthesized hardware.

### Non-blocking Assignments (`<=`)

-   **Behavior:** Executed **in parallel**. All right-hand sides are evaluated first, then all left-hand sides are updated simultaneously.
-   **Use Case:** For modeling **sequential logic** (registers) in `always @(posedge clk)` blocks. This correctly models how all flip-flops in a design capture data on the same clock edge.

### Golden Rules:
1.  **Sequential logic (`always @(posedge clk)`):** Use **non-blocking (`<=`)**.
2.  **Combinational logic (`always @(*)`):** Use **blocking (`=`)**.
3.  **Do not mix** them in the same `always` block.

---

## 2. Synthesis-Simulation Mismatch

A mismatch occurs when the pre-synthesis RTL simulation behaves differently from the post-synthesis gate-level simulation. This means the synthesized hardware is functionally incorrect.

### Common Causes:

1.  **Incorrect use of Blocking/Non-blocking Assignments:** The most frequent cause. A shift register written with blocking assignments will simulate incorrectly as a single wire but synthesizes into a different structure.
2.  **Incomplete Sensitivity Lists:** Missing a signal in a combinational `always` block's sensitivity list. Use `always @(*)` to prevent this.
3.  **Inference of Latches:** Incomplete `if` or `case` statements can cause the synthesizer to infer latches where none were intended.
4.  **Use of Non-Synthesizable Constructs:** Using simulation-only features like delays (`#10`) or display tasks (`$display`) in design code.

---

## 3. Gate Level Simulation (GLS)

GLS is the process of simulating the design **after synthesis**, using the gate-level netlist generated by the synthesis tool.

### Why is GLS Essential?

-   **Verification of Synthesis:** It confirms that the synthesis tool has correctly interpreted the RTL and the logic is functionally identical to the original design.
-   **Catching Mismatches:** GLS is the primary method for discovering synthesis-simulation mismatches.
-   **Timing Verification:** When combined with timing data, GLS can be used to verify that the circuit will meet its timing requirements (setup/hold times) at the target clock frequency.